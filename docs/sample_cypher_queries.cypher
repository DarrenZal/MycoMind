// MycoMind Sample Cypher Queries
// =================================
// These queries work with the knowledge graph generated by MycoMind's AI extraction pipeline.
// Since extraction results may vary between runs, these queries are designed to be flexible.

// =====================================
// 1. OVERVIEW & EXPLORATION QUERIES
// =====================================

// Count all nodes by type
MATCH (n) 
RETURN labels(n) as entity_types, count(n) as count
ORDER BY count DESC;

// Count all relationships by type
MATCH ()-[r]->() 
RETURN type(r) as relationship_type, count(r) as count
ORDER BY count DESC;

// Show all entities with their names and descriptions
MATCH (n) 
WHERE exists(n.name)
RETURN labels(n)[0] as type, n.name as name, 
       coalesce(n.description, n.bio, "No description") as description
ORDER BY type, name;

// Get database statistics
CALL db.stats.retrieve('GRAPH') YIELD data 
RETURN data;

// =====================================
// 2. PEOPLE (RegenerativePerson) QUERIES
// =====================================

// Find all people with their details
MATCH (person:RegenerativePerson) 
RETURN person.name as name, 
       person.location as location, 
       person.currentRole as role,
       person.bio as bio,
       person.organization as organization
ORDER BY name;

// Find people in specific locations (adaptable)
MATCH (person:RegenerativePerson) 
WHERE person.location IS NOT NULL
RETURN person.name as name, 
       person.location as location, 
       person.currentRole as role
ORDER BY location, name;

// Find people by role/expertise
MATCH (person:RegenerativePerson) 
WHERE person.currentRole CONTAINS "Developer" 
   OR person.currentRole CONTAINS "Engineer"
   OR person.bio CONTAINS "developer"
   OR person.bio CONTAINS "engineer"
RETURN person.name as name, 
       person.currentRole as role,
       person.location as location;

// Find people with highest extraction confidence
MATCH (person:RegenerativePerson) 
WHERE exists(person.extraction_confidence)
RETURN person.name as name, 
       person.extraction_confidence as confidence,
       person.location as location
ORDER BY confidence DESC;

// =====================================
// 3. PROJECTS (HyphalTip) QUERIES  
// =====================================

// Find all projects/tips with their status
MATCH (tip:HyphalTip) 
RETURN tip.name as name, 
       tip.description as description, 
       coalesce(tip.activityStatus, "unknown") as status,
       tip.created as created
ORDER BY name;

// Find active/alive projects
MATCH (tip:HyphalTip) 
WHERE tip.activityStatus IN ["alive", "active", "ongoing"]
   OR tip.activityStatus IS NULL  // Include tips without explicit status
RETURN tip.name as name, 
       tip.description as description,
       tip.activityStatus as status;

// Find projects with collaborators
MATCH (tip:HyphalTip)-[:COLLABORATOR|:COLLABORATESWITH]-(person)
RETURN tip.name as project, 
       collect(person.name) as collaborators,
       tip.description as description
ORDER BY project;

// =====================================
// 4. ORGANIZATIONS QUERIES
// =====================================

// Find all organizations
MATCH (org:Organization) 
RETURN org.name as name, 
       org.description as description,
       org.created as created
ORDER BY name;

// Find organizations and their members
MATCH (org:Organization)-[:HASMEMBER]->(member)
RETURN org.name as organization, 
       collect(member.name) as members,
       org.description as description
ORDER BY organization;

// Find organizations with most members
MATCH (org:Organization)-[:HASMEMBER]->(member)
RETURN org.name as organization, 
       count(member) as member_count,
       collect(member.name) as members
ORDER BY member_count DESC;

// =====================================
// 5. RELATIONSHIP ANALYSIS QUERIES
// =====================================

// Find all collaboration relationships
MATCH (entity1)-[r:COLLABORATOR|:COLLABORATESWITH]-(entity2)
RETURN entity1.name as collaborator1, 
       type(r) as relationship_type,
       entity2.name as collaborator2,
       labels(entity1)[0] as type1,
       labels(entity2)[0] as type2
ORDER BY collaborator1, collaborator2;

// Find all relationships in the graph
MATCH (n1)-[r]-(n2) 
RETURN n1.name as entity1, 
       type(r) as relationship, 
       n2.name as entity2,
       labels(n1)[0] as type1,
       labels(n2)[0] as type2
ORDER BY entity1, relationship, entity2;

// Find entities with the most connections (degree centrality)
MATCH (n)-[r]-() 
RETURN n.name as entity, 
       labels(n)[0] as type, 
       count(r) as connections,
       coalesce(n.description, n.bio, "") as description
ORDER BY connections DESC
LIMIT 10;

// Find membership relationships
MATCH (person)-[:MEMBEROF]->(org)
RETURN person.name as person, 
       org.name as organization,
       person.location as person_location
ORDER BY organization, person;

// =====================================
// 6. GEOGRAPHIC ANALYSIS QUERIES
// =====================================

// Find entities by location
MATCH (n) 
WHERE exists(n.location)
RETURN n.location as location, 
       count(n) as entity_count, 
       collect(n.name) as entities,
       collect(distinct labels(n)[0]) as entity_types
ORDER BY entity_count DESC;

// Find entities in the same location
MATCH (n1), (n2)
WHERE n1.location = n2.location 
  AND n1 <> n2 
  AND exists(n1.location)
RETURN n1.location as location,
       n1.name as entity1,
       n2.name as entity2,
       labels(n1)[0] as type1,
       labels(n2)[0] as type2
ORDER BY location, entity1, entity2;

// =====================================
// 7. ADVANCED PATH & NETWORK QUERIES
// =====================================

// Find paths between different entity types (adapt names as needed)
MATCH path = (start)-[*1..3]-(end)
WHERE labels(start)[0] <> labels(end)[0]  // Different entity types
  AND length(path) <= 3
RETURN start.name as from_entity,
       labels(start)[0] as from_type,
       end.name as to_entity,
       labels(end)[0] as to_type,
       length(path) as path_length
ORDER BY path_length, from_entity
LIMIT 20;

// Find shortest paths between specific entities (adapt names)
MATCH (start), (end)
WHERE start.name CONTAINS "MycoMind" 
  AND end.name CONTAINS "Transition"
MATCH path = shortestPath((start)-[*..5]-(end))
RETURN path, length(path) as path_length;

// Find entities that are both members and collaborators
MATCH (person)-[:MEMBEROF]->(org), 
      (person)-[:COLLABORATESWITH|:COLLABORATOR]->(project)
RETURN person.name as person, 
       org.name as organization, 
       project.name as project,
       person.location as location;

// Find triangular relationships (A knows B, B knows C, C knows A)
MATCH (a)-[r1]-(b)-[r2]-(c)-[r3]-(a)
WHERE a <> b AND b <> c AND c <> a
RETURN a.name as entity_a,
       b.name as entity_b, 
       c.name as entity_c,
       type(r1) as relationship_ab,
       type(r2) as relationship_bc,
       type(r3) as relationship_ca
LIMIT 10;

// =====================================
// 8. DATA QUALITY & METADATA QUERIES
// =====================================

// Find entities with highest extraction confidence
MATCH (n) 
WHERE exists(n.extraction_confidence)
RETURN n.name as entity,
       labels(n)[0] as type,
       n.extraction_confidence as confidence,
       n.extraction_date as extracted_on
ORDER BY confidence DESC
LIMIT 20;

// Find entities created recently
MATCH (n) 
WHERE exists(n.created)
RETURN n.name as entity,
       labels(n)[0] as type,
       n.created as created_date,
       coalesce(n.extraction_confidence, 0) as confidence
ORDER BY created_date DESC
LIMIT 20;

// Find entities by source file
MATCH (n) 
WHERE exists(n.source_file)
RETURN n.source_file as source,
       count(n) as entities_extracted,
       collect(n.name) as entity_names
ORDER BY entities_extracted DESC;

// Check for potential duplicates (similar names)
MATCH (n1), (n2) 
WHERE n1 <> n2 
  AND labels(n1) = labels(n2)
  AND n1.name CONTAINS n2.name OR n2.name CONTAINS n1.name
RETURN n1.name as entity1, 
       n2.name as entity2,
       labels(n1)[0] as type
ORDER BY type, entity1;

// =====================================
// 9. SCHEMA EXPLORATION QUERIES
// =====================================

// Explore the graph schema
CALL db.schema.visualization();

// List all node labels
CALL db.labels() YIELD label
RETURN label as node_types
ORDER BY label;

// List all relationship types
CALL db.relationshipTypes() YIELD relationshipType
RETURN relationshipType as relationship_types
ORDER BY relationshipType;

// List all property keys
CALL db.propertyKeys() YIELD propertyKey
RETURN propertyKey as properties
ORDER BY propertyKey;

// Find property distribution by entity type
MATCH (n)
UNWIND keys(n) as property
RETURN labels(n)[0] as entity_type, 
       property, 
       count(*) as usage_count
ORDER BY entity_type, usage_count DESC;

// =====================================
// 10. UTILITY & MAINTENANCE QUERIES
// =====================================

// Count total nodes and relationships
MATCH (n) 
WITH count(n) as node_count
MATCH ()-[r]->() 
RETURN node_count, count(r) as relationship_count;

// Find orphaned nodes (no relationships)
MATCH (n)
WHERE NOT (n)-[]-()
RETURN n.name as orphaned_entity, 
       labels(n)[0] as type
ORDER BY type, orphaned_entity;

// Find highly connected hubs
MATCH (n)-[r]-()
WITH n, count(r) as degree
WHERE degree > 2  // Adjust threshold as needed
RETURN n.name as hub_entity,
       labels(n)[0] as type,
       degree as connections
ORDER BY degree DESC;

// Performance: Create helpful indexes if they don't exist
// (Uncomment these if you want to add more indexes)
// CREATE INDEX FOR (n:RegenerativePerson) ON (n.name);
// CREATE INDEX FOR (n:HyphalTip) ON (n.name);
// CREATE INDEX FOR (n:Organization) ON (n.name);
// CREATE INDEX FOR (n:RegenerativePerson) ON (n.location);

// =====================================
// Notes:
// - These queries are designed to be flexible since AI extraction 
//   may produce different results each time
// - Adapt entity names and properties based on your specific data
// - Use LIMIT clauses for large datasets to avoid performance issues
// - Check query performance with PROFILE or EXPLAIN prefixes
// =====================================